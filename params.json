{"name":"LecceByBike - Ricostruzione dataset - Open Data Lecce Contest 2015","tagline":"JSON files and PHP scripts designed for the app \"Lecce By Bike\", proposed for Lecce's open data contest on 2015.","body":"# Open Data Lecce 2015\r\n\r\n### 1\tRICOSTRUZIONE DEI DATI\r\nUno dei principali obiettivi che si pone la raccolta dei dati, e la loro conseguente visualizzazione, è sicuramente la manutenibilità, la facilità nell’essere manipolati ma soprattutto la leggibilità, in modo che ogni cittadino sia in grado di interpretarli ed estrapolarne il significato. \r\nIl portale dedicati agli Open Data del Comune di Lecce pecca in alcuni di questi aspetti, più specificatamente nella scelta del formato di rappresentazione di alcuni dataset. Per la nostra applicazione avevamo bisogno di informazioni che potessero essere utilizzate dal cittadino per usufruire al meglio delle postazioni di Bike Sharing sparse per la città e delle piste ciclabili nella provincia di Lecce. Tali dati sono presenti sul portale tramite file in formato SHAPE, ottimi per rappresentazioni grafiche ma poco versatili nel caso si vogliano utilizzare gli stessi per manipolarli in ambiti applicativi diversi.\r\nDescriveremo ora il processo di ricostruzione dei dataset, partendo da quelli ottenuti dal portale e da altri siti, per poi modellarli e avere infine nuovi dataset che rispecchiano le caratteristiche di manutenibilità e di riusabilità conformi all’ingegneria del software.\r\n\r\n### 1.1\tPOSTAZIONI DI BIKE SHARING\r\nI file in formato SHAPE, come accennato precedentemente, sono poco propensi all’essere riutilizzati in altri ambiti al di fuori della rappresentazione grafica, inoltre è davvero difficile estrarre le coordinate dalla lista di punti fornita dal dataset. Per questo l’unico rimedio disponibile è stata l’estrazione manuale di ogni coppia di punti (latitudine e longitudine della postazione di bike sharing) e del relativo indirizzo attraverso la rappresentazione su mappa dei punti stessi.\r\nAll’indirizzo http://umap.openstreetmap.fr/it/map/stazioni-bike-sharing-comune-di-lecce_24533#15/40.3549/18.1765 è possibile avere un’anteprima delle postazioni sparse per la città, i cui dati si possono estrarre manualmente attraverso questa procedura:\r\n*\tClick col tasto destro su una postazione, indicata da una icona con una bici;\r\n*\tClick sull’opzione “Indicazioni stradali da qui”;\r\n*\tSi aprirà una nuova finestra e l’indirizzo associato conterrà al suo interno, come parametri alla chiamata della pagina web, la locazione della postazione di Bike Sharing e il relativo indirizzo.\r\n\r\nRipetendo questa procedura per tutte le postazioni ci permetterà di ottenere le informazioni a noi necessarie, la cui riorganizzazione prevede la creazione di un file formato JSON, che rappresenta uno standard per quanto riguarda facilità di comprensione, interoperabilità e soprattutto riusabilità in diversi ambiti applicativi (creazione di software, rappresentazione dinamica di dati, ecc…).\r\nIl JSON che creeremo ex novo sarà composto da 11 oggetti, ognuno dei quali sarà composto da 3 campi: address, latitude e longitude. Ogni oggetto della lista rappresenta l’insieme delle informazioni base di una postazione di bike sharing.\r\nEs:\r\n```sh\r\n[\r\n  {\r\n    \"address\": \"Viale Porta d'Europa, Lecce\",\r\n    \"latitude\": \"40.36165334640747\",\r\n    \"longitude\": \"18.169240951538086\"\r\n  },\r\n  …\r\n]\r\n```\r\n### 1.2\tPISTE CICLABILI DI LECCE E PROVINCIA\r\nIl dataset delle piste ciclabili offerto dal portale del Comune di Lecce affligge gli stessi problemi di quello relativo alle postazioni di Bike Sharing (in quanto anch’esso in formato SHAPE), quindi anche in questo caso si è presentato il vincolo di costruire un nuovo dataset che sfruttasse al meglio le peculiarità del formato JSON. In questo caso però le difficoltà si sono amplificate in quanto ogni pista ciclabile rappresenta un insieme di punti che, uniti ordinatamente dal primo all’ultimo, permettono di ottenere il tracciato della pista ciclabile. Da come si può intuire, ricostruire manualmente ogni dataset rappresenterebbe un lavoro troppo dispendioso e lungo, per questo si è virato verso nuovi dataset che fossero già semi-elaborati in partenza. La scelta finale è ricaduta sui dati forniti dal portale http://www.piste-ciclabili.com/comune-lecce che contiene tantissime informazioni sugli itinerari di Lecce e dintorni. Per ognuno dei 22 itinerari proposti dal portale, si è seguito il seguente iter:\r\n*\tDownload del tracciato dell’itinerario in formato CSV, contenete le due colonne longitude e latitude. Es:\r\n```sh\r\n;Longitude,Latitude\r\n18.096885681152,40.343469535337\r\n18.097043931484,40.34555255154\r\n…\r\n```\r\n*\tEstrazione manuale delle informazioni dell’itinerario ed inserimento di quest’ultime all’interno di un file JSON apposito per l’itinerario, formato dai seguenti campi:\r\n    * name:  nome dell’itinerario;\r\n    * description: descrizione associata all’itinerario;\r\n    * features: oggetto che riassume le informazioni contenute all’interno della scheda “Caratteristiche” associata alla pagina web di ogni itinerario. Questo oggetto contiene i campi:\r\n        * type: tipo di pista ciclabile\r\n        * distance: lunghezza del tracciato\r\n        * road_surface: tipo di fondo strada dell’itinerario\r\n        * is_suitable_for_children: valore booleano che indica se l’itinerario è adatto per i bambini\r\n        * is_suitable_for_skaters: valore booleano che indica se l’itinerario è adatto per i pattinatori\r\n    * details: oggetto che riassume le informazioni contenute all’interno della scheda “Dettagli” associata alla pagina web di ogni itinerario. Questo oggetto contiene i campi:\r\n        * average_slope: pendenza media del tracciato\r\n        * max_slope: pendenza massima del tracciato\r\n        * track_density: densità del tracciato\r\n        * difference: dislivello del tracciato (quota max-min)\r\n        * ascent_difference: dislivello in salita del tracciato\r\n        * descent:difference: dislivello in discesa del tracciato\r\n        \r\nEs:\r\n    \r\n```sh\r\n{\r\n  \"name\": \"Arnesano - Lecce\",\r\n  \"description\": \"Passeggiata tra le campagne, medio livello, con un punto in salita verso l'arrivo a Lecce.\",\r\n  \"features\": {\r\n    \"type\": \"strada\",\r\n    \"distance\": \"5.9 km\",\r\n    \"road_surface\": \"asfalto\",\r\n    \"is_suitable_for_children\": \"no\",\r\n    \"is_suitable_for_skaters\": \"no\"\r\n  },\r\n  \"details\": {\r\n    \"average_slope\": \"0.5 %\",\r\n    \"max_slope\": \"4 %\",\r\n    \"track_density\": \"5.7 punti/km\",\r\n    \"difference\": \"31 m\",\r\n    \"ascent_difference\": \"44 m\",\r\n    \"descent_difference\": \"18 m\"\r\n  }\r\n}\r\n```\r\n\r\n### 2\tINTEGRAZIONE DEL DATASET CON DATI DINAMICI\r\nNella fase precedente abbiamo analizzato i passi che hanno permesso la ricostruzione dei dati e la serializzazione degli stessi. La scelta di non scaricarli e di non farne il parsing in tempo reale è dettata dalla natura dei dati stessi, in quanto non tendono a cambiare spesso nel tempo.\r\nDati che invece tendono a cambiare e ad essere aggiornati sono più propensi ad essere scaricati e analizzati a runtime, nel momento in cui se ne intrevede la necessità di utilizzarli. In questa sezione spiegheremo quali sono i dati che abbiamo bisogno di interrogare a runtime e come pensiamo di utilizzarli.\r\n\r\n### 2.1\tPOSTAZIONI DI BIKE SHARING\r\nI dati statici che riguardano le postazioni di bike sharing sono decisamente scarni, in quanto di ogni postazione conosciamo solamente l’indirizzo e le coordinate. Il portale http://bicincitta.tobike.it/frmLeStazioni.aspx?ID=159 fornisce un servizio di monitoraggio in tempo reale delle postazioni di bike sharing, visualizzando informazioni molto utili come il nome, le bici libere, i posti disponibili e l’effettiva operatibilità per ogni postazione.\r\n\r\nPer estrarre queste informazioni dalla pagina web c’è bisogno di uno strumento che possa facilitare l’interpretazione del codice HTML e Javascript, e qui ci viene incontro l’applicazione Import.io, che permette il parsing di pagine web e di richiamare il risultato con una semplice query. Dopo diverse prove e alcune problematiche affrontate, il miglior approccio è stato quello di estrarre i dati e gestirli in una tabella formata da due colonne:\r\n* name: campo contenente il nome della postazione ed eventualmente una stringa che indica la sua effettiva operabilità\r\n* value: campo contenente il numero di bici libere e il numero di posti disponibili per postazione\r\n\r\nLa query effettuata da Import.io permette di ottenere la tabella appena descritta e di restituirla al chiamante attraverso un JSON che ha le seguenti fattezze: \r\n```sh\r\n{\r\n    \"offset\": 0,\r\n    \"results\": [\r\n        {\r\n            \"name\": \"Foro Boario\",\r\n            \"value\": \"0 bici libere 11 posti disponibili\"\r\n        },\r\n        …\r\n    ],\r\n    \"title\": \"Stazioni\",\r\n    \"pageUrl\": \"http://bicincitta.tobike.it/frmLeStazioni.aspx?ID=159\",\r\n    \"connectorGuid\": \"74ca0f38-5e47-4242-a52e-19d971952b15\"\r\n}\r\n```\r\n### 3\tSVILUPPO DEGLI SCRIPT PER UNIRE E RAFFINARE I DATI\r\nNei punti precedenti abbiamo ricostruito i dataset di base, sia statici che dinamici, che contengono le informazioni che dovranno essere trattate prima di restituirle all’utente finale. In questo punto spiegheremo come realizzare gli script che permetteranno di unire, raffinare e ridefinire nuovi dataset a partire da quelli di partenza ed ottenere, infine, i dataset nella loro forma definitiva.\r\nGli script sono realizzati in linguaggio PHP, linguaggio orientato ad oggetti che permette di realizzare script conformi agli standard dell’ingegneria del software, e i dataset restituiti saranno sempre in formato JSON, formato di interscambio leggibile e leggero, compatibile con qualunque dispositivo mobile e non presente sul mercato.\r\n\r\n### 3.1\tPOSTAZIONI DI BIKE SHARING\r\n\r\n1. Recupero dei dati dinamici in forma JSON (descritti nel punto 2.1) attraverso una query effettuata ai server dell’applicazione Import.io e memorizzazione del campo “results” facente parte del JSON appena ricevuto.\r\n3. Decodifica del file JSON, contenente gli indirizzi e le coordinate di ogni stazione di bike sharing, all’interno dell’oggetto bikeSharingCoordinates\r\n3. Per ogni oggetto presente all’interno dell’array queryResult\r\n    * Eliminare, nel caso esista, la dicitura “ Non operativa” dal nome della postazione di bike sharing e creare un nuovo campo “is_operative” che indica l’operatività effettiva della stazione.\r\n    * Trovare i valori numerici all’interno del campo “value”, attraverso un’espressione regex, e assegnarli rispettivamente ai nuovi campi “free_bikes” e “available_bikes”. Una volta assegnati, eliminare il campo “value” per risparmiare memoria.\r\n    * Copiare i valori dei campi “address”, “latitude” e “longitude” dall’oggetto contenuto nell’array bikeSharingCoordinates e inserirli nei rispettivi nuovi campi di queryResult.\r\n4. Convertire il vettore queryResult in formato JSON e restituirlo in output.\r\n\r\n```sh\r\n<?php\r\n\r\n$userGuid = \"b4de99c8-bc3e-42ac-9e66-0bbf9019ff22\";\r\n$apiKey = \"VX+ssJACaAbTXNbxWVf7bI0he+kkirPA0AHeUNxjk+eNDzDUCHo3axrfbz5rgUY1NpzdLZTS80l/Vq2i7JtR5A==\";\r\n\r\n// Issues a query request to import.io\r\nfunction query($connectorGuid, $input, $userGuid, $apiKey) {\r\n\t$url = \"https://query.import.io/store/connector/\" . $connectorGuid . \"/_query?_user=\" . urlencode($userGuid) . \"&_apikey=\" . urlencode($apiKey);\r\n\treturn json_decode(file_get_contents($url));\r\n}\r\n\r\n// Query for tile getBikeSharingStationsInfos\r\n$queryResult = query(\"74ca0f38-5e47-4242-a52e-19d971952b15\", array(\r\n  \"webpage/url\" => \"http://bicincitta.tobike.it/frmLeStazioni.aspx?ID=159\",\r\n), $userGuid, $apiKey, false)->results;\r\n\r\n// Decode bike sharing coordinates from json\r\n$bikeSharingCoordinates = json_decode(file_get_contents(\"bike_sharing_coordinates.json\"),true);\r\n//var_dump($bikeSharingCoordinates);\r\n\r\nfor($i = 0; $i < count($queryResult); $i++) {\r\n\t// cleanup values not well formed\r\n\t// create status class attribute and delete it from name attribute\r\n\tif (strpos($queryResult[$i]->name,' Non operativa') !== false) {\r\n\t\t$queryResult[$i]->name = str_replace(' Non operativa', '', $queryResult[$i]->name);\r\n\t\t$queryResult[$i]->is_operative = \"false\";\r\n\t} else {\r\n\t\t$queryResult[$i]->is_operative = \"true\";\r\n\t}\r\n\t\t\r\n\t// find numbers in value attribute and extract them\r\n\tpreg_match_all('!\\d+!', $queryResult[$i]->value, $matches);\r\n\t$queryResult[$i]->free_bikes = $matches[0][0];\r\n\t$queryResult[$i]->available_places = $matches[0][1];\r\n\t\r\n\t// once the numbers are extracted, value attribute will be deleted\r\n\tunset($queryResult[$i]->value);\r\n\t\r\n\t// get address and coordinates from json and set class attributes\r\n\t$queryResult[$i]->address = $bikeSharingCoordinates[$i][\"address\"];\r\n\t$queryResult[$i]->latitude = $bikeSharingCoordinates[$i][\"latitude\"];\r\n\t$queryResult[$i]->longitude = $bikeSharingCoordinates[$i][\"longitude\"];\r\n}\r\n\r\necho json_encode($queryResult);\r\n```\r\n\r\n### 3.2\tPISTE CICLABILI DI LECCE E PROVINCIA\r\n\r\n1. Ogni pista ciclabile ha una propria cartella al cui interno sono presenti un file CSV che rappresenta l’elenco delle coordinate del tracciato e un file JSON contenente le informazioni di base. Per questo, come primo passo, dobbiamo ottenere l’elenco delle cartelle all’interno di un array chiamato directories e allocare lo spazio per un nuovo array chiamato cyclePathsCompleteInfos che conterrà le informazioni unificate e rivedute.\r\n2. Per ogni oggetto contenuto all’interno del vettore directories\r\n    * Convertire il file CSV all’interno della cartella in un vettore di coordinate chiamato cyclePathCoordinates\r\n    * Decodificare il file JSON all’interno della cartella in un vettore chiamato cyclePathInfos\r\n    * Unire cyclePathCoordinates e cyclePathInfos e inserire l’oggetto unificato all’interno di cyclePathsCompleteInfos\r\n3. Convertire il vettore cyclePathsCompleteInfos in formato JSON e restituirlo in output.\r\n    \r\n```sh\r\n<?php\r\n\r\n// converts CSV file to array\r\nfunction convertCSVToArray($csvPath) {\r\n\t$result = array();\r\n\tif (($handle = fopen($csvPath, \"r\")) !== FALSE) {\r\n\t\t$column_headers = fgetcsv($handle); // read the row.\r\n\t\tforeach($column_headers as $header) {\r\n\t\t\t$header = str_replace(';', '', $header); //deletes ';' character from header\r\n\t\t\t$result[$header] = array();\r\n\t\t}\r\n\r\n\t\twhile (($data = fgetcsv($handle)) !== FALSE) {\r\n\t\t\t$i = 0;\r\n\t\t\tforeach($result as &$column) {\r\n\t\t\t\t\t$column[] = $data[$i++];\r\n\t\t\t}\r\n\t\t}\r\n\t\tfclose($handle);\r\n\t}\r\n\treturn $result;\r\n}\r\n\r\n// get all directories representing a cycle path\r\n$directories = array_filter(glob('*'), 'is_dir');\r\n// defines the result array that will contain every cycle path infos\r\n$cyclePathsCompleteInfos = array();\r\n\r\nfor ($i = 0; $i < count($directories); $i++) {\r\n\t$cyclePathCoordinates = convertCSVToArray($directories[$i].\"\\cyclepathcoordinates.csv\");\r\n\t$cyclePathInfos = json_decode(file_get_contents($directories[$i].\"\\cyclepathinfos.json\"),true);\r\n\t// merge infos and coordinates and put the new array into the i-th position\r\n\t$cyclePathsCompleteInfos[$i] = array_merge($cyclePathCoordinates, $cyclePathInfos);\r\n}\r\n\r\necho json_encode($cyclePathsCompleteInfos);\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}